**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group \#5:      |     |
| -------------- | --- |
| Student Names: |     |
| Danielle Jourdain               |     |
|                |     |
|                |     |

# 1 Introduction

Text…

# 2 Detailed description of unit test strategy

testing every method for DataUtilities
Range: one getter, contains, intersects, shift (2arg), expandToInclude

To develop our test cases, we will be using Equivalence Class Testing (ECT). This means we will begin our test development by partitioning the domain for each method. We will be using strong ECT to test the system. We will begin testing for each method by defining the domain of the method. We will then determine the different ranges in each domain for valid and invalid values. Then we will build a test case for every possible combination of domain ranges. This process will be described in depth in section 3 for each test case.

# 3 Test cases developed

## Range Test Development

### getLength() Testing

In order to test the getLength() method we created one test method. This method used a valid Range object and called the getLength method. This value was compared against the expected value for the length of that range. The method was called lengthShouldBeTwo.

### contains(double value) Testing

To test the contains method, 2 tests were created. The first one tested the contains method with a value contained within the Range. This test case ensured that the contains method returns true when the value is valid. The second test case ensured that the contains method returns false when the value is outside of the range. The two test methods were called containsShouldBeTrue and containsShouldBeFalse.

## DataUtilities Test Development

### calculateColumnTotal(Values2D data, int column)

To test this method, one test was created. This test used a mock for [REASONS]. The method was called calculateColumnTotalForTwoValues.

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

Text…

# 5 Difficulties encountered, challenges overcome, and lessons learned

Text…

# 6 Comments/feedback on the lab itself

Text…
