**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group \#5:      |     |
| -------------- | --- |
| Ethan Rigby          |
| Labib Afsar Ahmed    |
| Mohammed Alshoura    |
| Danielle Jourdain 

# 1 Introduction

Text…

# 2 Detailed description of unit test strategy

testing every method for DataUtilities
Range: one getter, contains, intersects, shift (2arg), expandToInclude

To develop our test cases, we will be using Equivalence Class Testing (ECT). This means we will begin our test development by partitioning the domain for each method. We will be using strong ECT to test the system. We will begin testing for each method by defining the domain of the method. We will then determine the different ranges in each domain for valid and invalid values. Then we will build a test case for every possible combination of domain ranges. This process will be described in depth in section 3 for each test case.

# 3 Test cases developed

## 3.1 Range Test Development

### 3.1.1 getLength() Testing

In order to test the getLength() method we created one test method. This method used a valid Range object and called the getLength method. This value was compared against the expected value for the length of that range. The method was called lengthShouldBeTwo.

### 3.1.2 contains(double value) Testing

To test the contains method, 2 tests were created. The first one tested the contains method with a value contained within the Range. This test case ensured that the contains method returns true when the value is valid. The second test case ensured that the contains method returns false when the value is outside of the range. The two test methods were called containsShouldBeTrue and containsShouldBeFalse.

### 3.1.3 shift(Range base, double delta) Testing

To Test the shift method, 3 tests were made. The first 2 shifted a range by a positive delta and a negative delta respectively. These tests ensured that the result of the shift is correct (they failed). The third test case was concerned with the no zero boundary crossing condition, which means that a shift of a negative number cannot become a postive number and will be set to zero. The methods were called  shiftRangeWithoutZeroCrossingPositveDelta, shiftRangeWithoutZeroCrossingNegativeDelta, and shiftShouldNotAllowZeroCrossing

### 3.1.4 intersects(double lower, double upper) Testing

To test the intersects method, 5 tests were created. THe functionality that had to be tested was the coverage by each of the two ranges. That is, we had to test the results of each one overlapping with each other in different ways. The first two tests were created by making the ranges match each other and by making them not intersect at all. Both of these tests passed (intersectsRangeFullyOverlapsSpecifiedRange and intersectsRangeDoesNotOverlapSpecifiedRange). However, when creating tests to make sure no edge cases would fail, not all tests passed. A test case seems to fail if the specified range intersects the range but does not fully encompass it. E.g., if my Range is (-1, 1) and my specified lower bound is not <= -1 with the upper bound being >= 1, it will return false. The tests that did not pass were intersectsRangePartiallyOverlapingSpecifiedRange and intersectsSpecifiedRangeFullyCoveredByRange while intersectsRangeFullyCoveredBySpecifiedRange passed.

## 3.2 DataUtilities Test Development

### 3.2.1 calculateColumnTotal(Values2D data, int column)

To test this method, three tests were created. These tests used mocks to test the functionality of the calculateColumnTotal method. This is because this method is dependant on the Values2D interface. Therefore a mock of the Values2D interface was created. The first test for this method was checking the calucation of a valid data object with 1 column containing 2 rows and a valid column number. The second test used an invalid column number to ensure the method returned 0. A third test was created to ensure the method would return 0 if the Values2D data was empty. These teste were called calculateColumnTotalForTwoValues, calculateColumnTotalReturnsZeroForInvalidValue, and calculateColumnTotalReturnsZeroForEmptyValue2D respectively.

3.2.2 calculateRowTotal(Values2D data, int row)

To test this method, three test cases were created. Mock data had to be created for the Values2D in order to test the functionality of calculateRowTotal. Since Values2D is not the method/class being tested, a mock object was created for it as to not interfere in the validity of these tests. As this method is similar to 3.2.1, each test case follows a similar path with the main change being to test the rows instead of columns. This allows for easier readability in the code while ensuring that both calculateColumnTotal and calculateRowTotal work as expected and follow the same guidelines. The tests created for this method were called calculateRowTotalForTwoValues, calculateRowTotalReturnsZeroForInvalidValue, and calculateRowTotalReturnsZeroForEmptyValue2D.

### 3.2.3 getCumulativePercentages(KeyedValues data)
To test this method, two tests were created. These Teests used mocks to test the funciton getCumulativePercentages. The mocks were used because the method is dependant on a KeyedValues and the methods it has, so a mock of a KeyedValues object was created. The first test was checking whether the returned KeyedValues object perserved the keys, and whether the percentages it generated are accurate and added up to 1. The second test was concerned with negative values, and whether the returned object had values between 0 and 1 for the percentages, since we suspected negative values may not have been handeled. These tests were called getCumulativePercentagesForAllPositiveDataObject and getCumulativePercentagesForNegativeDataObject

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

First the team met together during the lab to understand the assignment. We worked through the sample code that was given in the lab document together. Then we moved on to developing our first set of unit tests. We did this as a group gathered around one computer to ensure we all understood the process that was required. Afterwards, we split up the remaining methods to test. We each tested one method for Range and one to two methods for DataUtilities.

# 5 Difficulties encountered, challenges overcome, and lessons learned

Text…

# 6 Comments/feedback on the lab itself

Text…
