**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group \#5:      |     |
| -------------- | --- |
| Ethan Rigby          |
| Labib Afsar Ahmed    |
| Mohammed Alshoura    |
| Danielle Jourdain 

# 1 Introduction

Text…

# 2 Detailed description of unit test strategy

testing every method for DataUtilities
Range: one getter, contains, intersects, shift (2arg), expandToInclude

To develop our test cases, we will be using Equivalence Class Testing (ECT). This means we will begin our test development by partitioning the domain for each method. We will be using strong ECT to test the system. We will begin testing for each method by defining the domain of the method. We will then determine the different ranges in each domain for valid and invalid values. Then we will build a test case for every possible combination of domain ranges. This process will be described in depth in section 3 for each test case.

# 3 Test cases developed

## 3.1 Range Test Development

### 3.1.1 getLength() Testing

In order to test the getLength() method we created one test method. This method used a valid Range object and called the getLength method. This value was compared against the expected value for the length of that range. The method was called lengthShouldBeTwo.

### 3.1.2 contains(double value) Testing

To test the contains method, 2 tests were created. The first one tested the contains method with a value contained within the Range. This test case ensured that the contains method returns true when the value is valid. The second test case ensured that the contains method returns false when the value is outside of the range. The two test methods were called containsShouldBeTrue and containsShouldBeFalse.

### 3.1.2 shift(Range base, double delta) Testing

To Test the shift method, 3 tests were made. The first 2 shifted a range by a positive delta and a negative delta respectively. These tests ensured that the result of the shift is correct (they failed). The third test case was concerned with the no zero boundary crossing condition, which means that a shift of a negative number cannot become a postive number and will be set to zero. The methods were called  shiftRangeWithoutZeroCrossingPositveDelta, shiftRangeWithoutZeroCrossingNegativeDelta, and shiftShouldNotAllowZeroCrossing

## 3.2 DataUtilities Test Development

### 3.2.1 calculateColumnTotal(Values2D data, int column)

To test this method, two tests were created. These tests used mocks to test the functionality of the calculateColumnTotal method. This is because this method is dependant on the Values2D interface. Therefore a mock of the Values2D interface was created. The first test for this method was checking the calucation of a valid data object with 1 column containing 2 rows and a valid column number. The second test used an invalid column number to ensure the method returned 0. These teste were called calculateColumnTotalForTwoValues() and calculateColumnTotalReturnsZeroForInvalidValue() respectively.

### 3.2.2 getCumulativePercentages(KeyedValues data)
To test this method, two??? tests were created. These Teests used mocks to test the funciton getCumulativePercentages. The mocks were used because the method is dependant on a KeyedValues and the methods it has, so a mock of a KeyedValues object was created. The first test was checking whether the returned KeyedValues object perserved the keys, and whether the percentages it generated are accurate and added up to 1. The second test ????. These tests were called getCumulativePercentagesForValidDataObject and ???

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

First the team met together during the lab to understand the assignment. We worked through the sample code that was given in the lab document together. Then we moved on to developing our first set of unit tests. We did this as a group gathered around one computer to ensure we all understood the process that was required. Afterwards, we split up the remaining methods to test. We each tested one method for Range and one to two methods for DataUtilities.

# 5 Difficulties encountered, challenges overcome, and lessons learned

Text…

# 6 Comments/feedback on the lab itself

Text…
